硬件抽象层,
	为客户机操作系统呈现和硬件相同或相近的硬件抽象层.
系统层,
	操作系统内核提供多个相互隔离的用户态实例.
函数库层,应用层.

通过虚拟化层(vmm)的模拟来提供独立的虚拟机执行环境

   虚拟机  
     |
虚拟硬件抽象层,
     |
  虚拟化层
(硬件抽象层)
    硬件
x86平台
	需要基于软件(bt)实现完全虚拟化.
	类虚拟化技术修改操作系统源码与vmm软件协同工作.
	vt,svm,硬件辅助的完全虚拟化.操作系统不需要做修改.
x86 内存架构
物理地址空间,由cpu实现的物理地址位数所决定.内存和其他硬件设备等可用资源分布在cpu的物理地址空间内.
线性地址空间,有cpu实现的线性地址位数所决定,为了让多个程序能够有效相互隔离和使用物理地址空间的资源.
地址
逻辑地址,程序直接使用的地址.比如指针.
线性地址,又称为虚拟地址,用于索引线性地址空间.
物理地址,是cpu提交到总线用于访问资源的最终地址.
分段,分页未启用:逻辑地址>线性地址=物理地址
分段,分页启用:逻辑地址>线性地址>物理地址
内存管理机制
分段机制
是内存管理机制,将内存划分成以起始地址,长度描述的块称为段.
分段机制:逻辑地址(包含段选择符),段选择起存器,段描述符(段的基地址,长度,各种属性)->如果合法将可根据段描述符将逻辑地址转换成线性地址,段描述符表.
段选择符.  索引(index),描述符表(t1),权限级别(rpl)  //6个段寄存器
段描述符. cpu将段描述符中32位的基地址和逻辑地址中32位偏移量相加得到对应的线性地址. //对程序不可见,段描述符寄存器.
段描述符表,
	gdt,系统中至少有一个,可以被所有进程访问.是内存中的一个数据结构,(基地址,长度)
	ldt,系统中可以有一个或多个可以被某个进程私有.是一个段,需要描述符(存放gdt)描述,
	
分页机制
是更加粒度化的内存管理机制,用页来管理线性地址空间和物理地址空间,
页表
线性地址对应的页帧号叫虚拟页帧号,物理地址对应的页帧号叫物理页帧号,
页表存储从虚拟页帧号到物理页帧号映射的数据结构.
目录(31-22)|表(21-12)|偏移(11-0)

页目录中存放页目录项(4B,包含页表的物理地址),cpu使用线性地址22-31位索引页目录.
页表项(4B)存放在页表中,
基地址+0-11位偏移量得到线性地址对应的物理地址。
地址对齐到页边界后的值为页帧号，是该地址所在页面的基地址。

页目录项和页表项中p字段
p=1：物理页面存在于物理内存中，cpu完成地址转换之后可以直接访问该页面。
p=0：页面不在物理内存中，cpu访问该页面时产生缺页错误，并交给操作系统的缺页错误处理程序处理。通常将存在于磁盘上的页面
调入物理内存。

进程运行前将其页目录的基地址存入cr3.页目录的基地址对齐到4k边界。

TLB
对最近用到的页面映射进行缓存。页面映射存在与tlb中时无需查找页表就能进行地址转换。
vfn>pfn的转换。
刷新tlb
1，刷新cr3，比如进程切换，是的老进程在tlb中的条目失效。
2，invlpg指令，对tlb中单独的页目录项目，页表项进行刷新。

基本寄存器组 7类
通用寄存器，8个32位，保存程序运行时的临时变量，栈指针等数据。
内存管理寄存器，包括段寄存器和描述符表寄存器。
。
。
控制寄存器，5个cr0-cr4，决定了cpu运行的模式和特征。

权限控制
段保护
	当前权限级别，cpl0-3 ring级别 cs寄存器0-1位
	描述符权限级别，dpl，段和门，<=dpl的代码可以访问该数据段
	要求权限级别，rpl，段寄存器0-1位，
页保护
	在页目录项页表项引入一个User/supervisor位，0时表示s，cpl 0.1.2,可以访问所有页面，
	1时表示u，cpl=3只能访问user页面。
中断与异常
中断架构
这里太难了。。。。。



进程
程序是一个静态的指令序列，进程则是一个容器，包括执行一个程序的特定实例时用到的各种资源。
资源包括私有的线性地址空间，可执行的程序（代码和数据），已经获得的其他资源，进程的权限，进程的描述符。
上下文
上下文切换，相关寄存器的值切换
1用户态到内核态的切换2.进程切换例如把cr3换成新进程页目录的地址，eip指向新进程的第一条指令。
3.到中断上下文的切换

进程上下文-中断上下文（处理中断）-进程上下文（中断执行返回）
进程上下文-中断上下文-新进程上下文（处理中断）-进程上下文（最先被打断的进程）
中断上下文-新中断上下文
保存旧的上下文，上下文相关寄存器的值保存在内存中。
加载新上下文，从内存中读入，加载入对应的寄存器中。


I/O
1 port I/O 通过I/O端口访问设备寄存器 I/O端口的地址空间，是独立的，不是线性地址空间或物理地址空间的一部分。
cpu通过一个特殊的管脚标识I/O端口访问
2 mmio内存映射io，通过内存访问的形式访问设备寄存器或设备ram
mmio要占用cpu的物理地址空间，把设备寄存器或设备ram映射到物理地址空间上。
整个物理地址空间被映射到线性地址空间，所以要访问I/O资源要做线性到物理地址的转换。

DMA（都使用物理地址访问内存）
直接内存访问。驱动程序事先设定一个内存地址，不用经过cpu直接向内存中复制或读取数据。
同步dma
  软件发起的，驱动将存放的地址通知设备，设备从内存直接读取数据。
异步dma
 设备将数据直接复制到一个事先设定好的内存地址，再中断通知驱动程序。

PCI设备
通过桥pci总线可以很容易的被扩展。并与其他总线相互挂接，构成整个系统的总线网络。

设备标识符
bus（8-15）|device（3-7）|function（0-2）
8位bus代表设备所在的总线号，
device代表在bus所表示总线上的某个设备。
function表示功能号表示具体设备上的某个功能单元（逻辑设备）。

pci bar 基地址寄存器
用于报告设备寄存器或设备ram在i/o端口地址空间（pirt i/o）或物理地址空间中的地址（mmio），根据最后一个标识位。
pci bar 可预取，不可预取，根据第3个位判断。

中断针脚
pci中断线标准 int（abcd）对应0-3，
设备中断线
保存作用。bios用它保存设备所连接的pci/ioapic管脚号


虚拟化概述
一般虚拟环境有：硬件，vmm ，虚拟机。

操作和管理关键系统资源的指令，特权指令。
在虚拟化中 敏感指令：操作特权资源的指令。所有的特权指令都是敏感指令。
敏感指令必须在vmm监控下或由vmm来玩成。陷入再模拟（软件模拟指令执行效果）
所有敏感指令都是特权指令则是可虚拟化结构。否则他无法在所有敏感指令上出发异常，就不是可虚拟化结构，成为虚拟化漏洞。

命令的模拟
vmm运行在最高特权级
处理器虚拟化的关键在于正确模拟指令的行为。
物理处理器，包括存放数据的物理寄存器，规定使用这些寄存器的指令集。
物理处理器中寄存器状态构成了当前进程上下文状态
eip当前进程执行的指令esp当前进程的堆栈指针等

虚拟处理器
	vmm通过修改客户机系统源代码使vmm正确模拟虚拟机期望的运行模式:
	指令集合与执行效果,
	可用寄存器集合,包括通用寄存器以及各种系统寄存器,
	运行模式.
	地址翻译系统,如页表
	保护机制
	中断异常机制,


	敏感指令陷入vmm
	基于处理器保护机制触发异常,处理器在执行之前检查其执行条件是否满足.
	虚拟机主动出发异常,出发陷阱指令主动请求陷入到vmm中
	异步中断,包括处理器内部的中断源和外部的设备中断源.时间片用完,强行中断当前指令

	中断和异常的模拟及注入
	异常保障了系统程序对处理器关键资源的绝对控制
	中断提供了与外设之间更有效的一种交互方式.

	对于异常.vmm需要区分两种原因:
	虚拟机自身对运行环境和上下文的设置违背了指令正确执行条件
	由陷入再模拟的虚拟化方式造成

	物理中断的触发来自特定的物理中断源.虚拟中断的触发来自于虚拟设备的模拟程序.



	svm
	多处理器虚拟化技术
	vmm面临的物理处理器之间及虚拟处理器之间的同步问题。
	1，vmm自身代码之间的同步问题，由vmm负责协调物理处理器之间的同步
	2，同一个虚拟机内部，靠操作系统实现
	3，虚拟机n个虚拟处理器，物理处理器有m个，虚拟到物理的迁移需要vmm负责同步状态。

	启动，bios负责选取bsp主启动处理器与ap应用处理器，初始化到某种状态，bios在bsp上启动加载程序boot loader,跳到操作系统初始化代码。
	同时所有ap处于等待初始化硬件信号状态。操作系统给ap初始化硬件信号并指定启动代码。最终操系统初始化了所有的处理器。

内存虚拟化
	1，正常情况下物理内存地址从0开始，系统启动启动的时候加载访问指定地址。操作系统对内存连续性存在一定程度的依赖。
	2，内存是连续的，至少在一些大粒度上连续。

	vmm欺骗客户机操作系统，来满足客户机操作系统对内存的两点要求，这个过程就叫做内存虚拟化。
	其核心在于引入一层新的地址空间，客户机物理地址空间。
	wmm的主要工作
	1，给定一个虚拟机维护客户机物理地址到宿主物理地址之间的映射关系。F1(GVA)=GPA  F2(GPA)=HPA
	2，截获虚拟机对客户机物理地址的访问，并根据映射关系转换成宿主物理地址。

	VMM和客户机操作系统运行在不同的地址空间里，限制客户机操作系统可使用的大小，vmm|客户机
	vmm通过权限验证机制，使客户机局限在指定的地址空间里，客户机|客户机
	vmm防止客户机dma越权访问。

I/O虚拟化

i/o端口寄存器，被映射到i/o地址空间中。
mmio寄存器，被映射到物理地址空间中。
中断，外设速度低于处理器，所以需要异步事件通知的方式来完成延后的操作。在处理器的中断向量空间分配一个序号。
i/o端口，mmio，中断模块是典型的外设呈现给软件的基本资源。

截获客户机操作系统对外设的访问请求，通过软件模拟真实的物理设备效果，模拟过程就叫做i/o虚拟化。
虚拟完毕之后，只要客户机操作系统中有驱动程序遵守该虚拟设备的接口定义就可以使用。

设备发现
	vmm提供一种方式让客户机操作系统发现虚拟设备，加载相关驱动程序。
	模拟一个所处物理总线设备包括
		1，所处总线类型是不可枚举物理设备，该设备本身所属资源是硬编码固定下来的。vmm需要在指定端口进行正确的模拟。
		2，所处总线类型是可枚举物理设备，比如pci设备
	模拟一个完全虚拟的设备
		这种设备所处的总线类型由vmm决定，可挂在pci总线上，可以完全定义新的虚拟总线驱动协议。
访问截获
	截获客户机操作系统对虚拟设备的访问，并进行模拟。关键点在于处理器虚拟化。
	对于一个非直接分配给客户机操作系统使用的设备:
	设备提供端口i/o资源:
	处理器对于端口i/o资源的控制在于指令流所处的特权级别和相关i/o位图，由于客户机降级运行，其能不能访问给定i/o端口取决于i/o位图。
	vmm把设备的所有端口i/o从位图中关闭，这样客户指令流在访问该i/o端口时，物理处理器抛出异常，vmm可以获取异常原因。然后将请求发送给设备模拟器进行模拟。
	设备提供mmio资源:
	对于mmio它本身也是物理地址空间的一部分，至于要设置其页表的有效与无效就可以了。不需要对设备的访问进行模拟。
	如果可以产生中断:
	vmm需要提供机制,物理中断并需要触发中断时>设备模拟器>通知到虚拟中断逻辑>逻辑模拟一个中断的注入.
	如果直接分配给客户机使用的设备,vmm接收物理中断之后辨认出中断源所属客户机,通知其虚拟中断逻辑.
	设备如果可以dma或类似共享内存,这时候需要设备模拟器了解各种地址之间的转换关系.
设备模拟
	虚拟实现可以与现实设备具有完全一样的接口定义,这样客户机中原有的驱动无需修改就可以驱动这个虚拟设备.显示设备具有那些资源,设备模拟器需要呈现出同样的资源.
	简化驱动程序,客户机中的驱动程序为前端设备驱动,vmm中的驱动为后端设备驱动.
设备共享
	vmm可以选择性的虚拟化不同设备,1,模拟器用软件完全模拟.cmos.2,模拟器进一步去请求物理驱动程序的帮助.一般输入输出类设备.
	设备模拟器运行在一个i/o特权环境中,这样的环境中有物理驱动程序,这种情况下设备模拟器本身作为物理驱动程序的一个客户,特权环境中的物理驱动程序可以同时接收多个
	请求,虚拟机中有专属的设备模拟逻辑,在i/o特权环境中有一个相对应的用户进程.可以将物理资源在虚拟环境中复用.
	i/o特权环境         |    vm
		           | 
	物理驱动<--设备模拟器 |
		   模拟设备 |<----驱动程序

vmm的功能和组成
	虚拟环境的管理(所有vmm产品需要提供的基本功能)
		虚拟资源:
		处理器虚拟化模块,内存虚拟化模块,设备虚拟化模块.
		虚拟环境的调度:
		多个客户机操作系统并发执行,vmm需实现有效的调度.vmm的调度是虚拟处理器之间的调度.
		虚拟机间通信机制:
		vmm实现虚拟机间的通信机制,vmm提供api,可以是事件通知,也可以是内存共享等.
		虚拟化环境的管理接口:
		由上层的管理程序和vmm提供的管理接口组成,vmm提供接口来支持各种功能,上层的管理程序调用为用户提供管理界面.
	物理资源的管理(根据实现结构的差异,其存在各有差异)
	处理器管理:
		获取所有处理器,对每个处理器进行初始化,比如运行模式,设置页表,设置中断处理函数等.
	内存管理:
		vmm检测并获取所有内存,初始化内存包括分页,设置页表.
	中断管理:
		vmm负责初始化并设置中断相关资源,比如处理器中断向量表,中断控制器,vmm接受中断,根据中断来源,直接处理或者转发到相关特权虚拟机来处理.
	系统时间维护:
		vmm拥有和时间相关的硬件资源,vmm维护系统时间,向各虚拟机提供虚拟化的时间.
	设备管理:
		混合模型下,大部分的外部设备属于特权客户操作系统,由特权客户操作系统的驱动程序来管理这些外设.

vmm的分类
按虚拟平台分类
1,vmm虚拟的是现实存在的平台,在客户机看来虚拟的平台和现实的平台是一样的,可以运行现有的操作系统,无需修改,叫完全虚拟化.
2,vmm虚拟的平台是显示中不存在的,经过vmm重新定义的.需要对客户机操作系统进行修改来适应虚拟环境,叫类虚拟化.
完全虚拟化:
	vmm需要能够正确处理所有可能的指令,也就是其模拟的处理器规范上定义的所有指令.
完全虚拟化经历了两个阶段:
	软件辅助完全虚拟化
		优先级压缩
			vmm在ring0,客户机操作系统内核在ring1,客户机操作系统应用程序在ring3,ring1触发异常vmm截获再虚拟化.
			有的指令在ring1中没有出发异常.
		二进制代码翻译
			用来处理那些虚拟化不友好的指令.扫描并修改客户机的二进制代码,将难以虚拟化的指令转换为支持虚拟化的指令块,指令块与vmm合作访问受限的虚拟资源,或显示触发异常让vmm进一步处理.
	硬件辅助完全虚拟化	
		vt-x在处理器上引入了一个新的执行模式用于运行虚拟机,只是任何特权操作都会被处理器截获并报告给vmm.vmm找到对应的虚拟化模块进行模拟.

类虚拟化:
	是通过在源代码级别修改指令以回避虚拟化漏洞,修改操作系统的处理器相关代码,让操作系统主动让出特权级别而运行在次一级的特权上,如果执行特权指令,保护异常被触发,vmm可以截获模拟.可以高度优化i/o协议,完全基于事务,速度很快.

按vmm实现结构分类
hypervisor管理物理资源,虚拟化功能.
	在hypervisor中vmm被看做是一个完备的操作系统,与传统的操作系统不同的是,vmm是为虚拟化而设计的.因此还具备虚拟化功能.
	所有的物理资源都归vmm所有,vmm管理物理资源,还需要向上提供虚拟机用于运行客户机操作系统.vmm负责虚拟环境的创建和管理.

	dm设备模型(负责i/o设备的虚拟化),
	p处理器管理代码(物理处理器的管理和虚拟化),
	m内存管理代码(物理内存的管理和虚拟化),
	dr设备驱动(负责i/o设备驱动)
	虚拟机的安全只依赖于vmm的安全.
	vmm由于需要进行物理资源的管理,而驱动开发工作量很大,所以基于hypervisor的vmm通常会挑选一些i/o设备来支持.
	基于hypervisor模型中,很多功能必须在vmm中重新实现.不能像宿主模型那样借助宿主机操作系统.
	
宿主模型
	物理资源由宿主机操作系统管理,这些操作系统不是为虚拟化设计的,因此本身不具备虚拟化功能,实际的虚拟化功能由vmm来提供,
vmm通常是宿主机操作系统独立的内核模块,vmm通过调用宿主机操作系统的服务来获取资源进行虚拟化,效率和功能会有影响.
	虚拟机的安全不进以来vmm的安全也依赖于宿主机操作系统的安全.

混合模型
	上述模式汇合.hypervisor(vmm)位于最底层拥有所有的物理资源.不同的是vmm会主动让出大部分i/o设备的控制权.交由一个运行在特权虚拟机中的特权
操作系统来控制.i/o的虚拟化由vmm和特权操作系统共同合作来完成.dm位于特权操作系统中,与vmm通信合作.vmm和特权操作系统的切换如果频繁时会降低性能.


虚拟化产品及其特点
vmware
微软
xen(混合)
kvm(宿主或hypervisor)


给予软件的完全虚拟化
cpu虚拟化
在硬件弥补漏洞之前基于软件的cpu完全虚拟化.
相同硬件体系结构,不同硬件体系结构.
解释执行
	编译好的二进制代码不会被载入物理cpu直接运行,而是解释器逐条解码,再调用对应的函数来模拟其功能.
	模拟与物理机相同体系结构的虚拟机性能很差.
扫描与修补
	让大多数指令直接在物理cpu上运行,而把操作系统中的敏感指令替换成跳转指令或会陷入到vmm中去的指令.
	1,vmm在虚拟机开始执行代码之前进行扫描,解析每条指令,查找到特权指令和敏感指令.
	2,补丁代码在vmm中动态生成,每一个需要修补的指令会对应一块补丁代码.
	3,敏感指令被替换成一个外跳转,从虚拟机跳到vmm空间里,在vmm中执行动态生成的补丁代码.
	4,补丁代码执行完毕,执行流再跳回虚拟机中继续执行.
二进制代码翻译
	基本块,只有一个入口和一个出口的代码块,不会从中间跳出,外边跳不进去.
	翻译.模拟器对读入的二进制代码不做限制,可以是应用程序代码,可以是操作系统内核代码,读入的二进制代码可能包含所有的
	体系结构的指令,模拟器将其翻译输出为一个安全的不包含特权指令和敏感指令的子集,能够运行在用户态.

	































